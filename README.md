# 00_Uncategorized
Uncategorized test demo either Blueprint or C plus plus.

> 所有出现的`LS`字段均代表`Level Sequence`，`AS`字段均代表`Actor Sequence`

# Sequencer编辑器

## 混合动画

在Sequence中，为一个骨骼模型添加多段动画时，混合方式有两种：
1. 将多段动画在Sequencer编辑器中置于同一行，并且前后两者有重叠部分，重叠的部分可以右键选择混合选项，使用什么样的曲线方式来混合
2. 将多段动画在Sequencer编辑器中置于不同行，分别在同一时刻（帧）二者都执行的交界处为各自的动画的**权重(Weight)**属性打关键帧，后设置属性值即可混合。Tips：往往在时间轴前的动画权重从1开始，前者动画结束处设为0；位于后者的动画权重从0开始，前者动画结束处设为1。

## 一种实现思路

不太好命标题，大概情景是这样的：

首先是要用到AS，UE4.18可以在插件设置中看到UE自带插件`Actor Sequence`默认启用了，而还有一个插件`Actor Sequence Editor`未启用。区别是如果不启用后者，那么你在Actor中添加AS组件时，组件的Sequence是无法像LS那样编辑的。UE4.24已经看不到`Actor Sequence Editor`插件了，功能集成到了`Actor Sequence`插件里。

其次，说一下具体情况，我想做一个Actor，这个Actor管理一个情景，假设把它定为`铁路施工人员在铁轨上施工`。那么我可能想要三个骨骼模型（甲乙丙）来模拟，甲蹲下去施工，乙低头走路后转身和丙对话，丙在乙走路时四处张望再转身听乙说话。

这个情景我想做成循环播放的，什么意思呢，就是只要AS播放了，该情景就能一直往复，而且从本次播放结尾到下次播放开始，甲乙丙的状态信息是和本次保持一致的，不会出现闪动现象。

其次，我想做另外一个情景，假设铁路上有车驶向了这三人，甲被撞到了，此时乙丙会向铁轨两侧跑，以免被撞到。该动画只播放一次，且要从当前循环播放时不知道的具体位置开始进行一系列动画+路径变换。

做法：对于乙或丙来说，使用一个AS，包含两段动画，第一段是循环播放，第二段是触发播放一次。

如何实现呢？

首先，乙的第一段动画假如在0-5秒，第二段动画放置在了10-15秒，这之间的5-10秒是空白，什么操作也不做。我在Actor的BeginPlay中让AS组件开始播放，并在Tick中检测当前动画是否播放到第一段动画的结尾处，(对象是`Move Scene Player`)使用`GetCurrentTime`函数，如果到达了第一段结尾处，使用`JumpTo`函数将当前动画位置跳转到第一段动画起始位置。有点类似于写代码中的goto，当前动画位置有点类似于游标。怎么好理解怎么来。

接下来是为甲创建碰撞事件，一旦触发碰撞，这时将乙或丙的动画当前位置跳转到第二段动画开始，让其执行后续的动画即可。

那么问题来了，对于不确定碰撞时机，不确定角色动画执行到什么位置时，如何为角色先行制作触发动画呢？

答案是：**采用相对位移变换，也就是Transform的Relative分段**。这样就可以解决问题。注意加了相对分段后，假如和绝对分段有重叠部分，绝对分段的权重要改为0，不然会出现一些看似有规律但并没多大意义的`和预想中的偏移`。

TODO 待解决问题，虽然是可以在当前位置触发下一段动画了，但是当前骨骼模型的姿势也不好确定，怎么将其混合到下一段动画的起始姿势中呢？好好思考一下。


# 绝对位置和相对位置的分析

因为位置、旋转、缩放这些变换信息总是伴有绝对和相对两种概念，因此这里通过实例探究进行细致地剖析每一种用法以及适用的场景。

## AttachToActor的选项分析

首先我们知道，在UE4Editor编辑器中可以向关卡放置Actor，而在世界大纲中我们可以将一个Actor`挂在/附加到`另一个Actor下，这时这两个Actor就有了一种关系，因此`附属/子级`的Actor也就拥有了绝对和相对的区别。

先说Actor旋转量为`(0, 0, 0)`的情况，此时你选中的父级Actor，查看它的世界轴向和物体轴向是完全一致的。当这个Actor在世界中的绝对位置为`(100, 100, 100)`时，如果此时附加一个Actor，并将Actor的相对位置设置为`(50, 50, 50)`，那么该Actor在世界中的绝对位置其实就是`(150, 150, 150)`。这应该不难理解。旋转也是同理，


ActorSequence中对组件添加的Transform分段不管哪一种，都是基于组件的Actor(假设名字为A)的轴向的。不是基于组件自身轴向也不是基于ActorA挂载的Actor(假设名字为B)的轴向。

AttachToActor函数附加选项有三种。分别是KeepRelative, KeepWorld, SnapToTarget。

假设ActorA原本已附加在ActorC上，ActorA原有的绝对位置为(100,100,100)，原有的相对位置为(50,50,50)，此时将ActorA附加在ActorB上时：

1. 如果采用KeepRelative策略，会基于ActorB的自身轴向，将ActorA的相对信息保留，即附加后，ActorA的相对位置仍然是(50,50,50)；
2. 如果采用KeepWorld策略，则会保持ActorA的绝对位置(100,100,100)不变，基于ActorB重新计算ActorA在ActorB的相对位置；
3. 如果采用SnapToTarget策略，会使ActorA使用ActorB的坐标轴，也就是会屏蔽掉ActorA的位置信息，哪怕ActorA的原有相对位置为(50,50,50)附加后相对位置也会变成(0,0,0)。

## Sequence中Transform分段的选项分析

帅哥。结果分析出来了。
ActorSequence中对组件添加的Transform分段不管哪一种，都是基于组件的Actor(假设名字为A)的轴向的。不是基于组件自身轴向也不是基于ActorA挂载的Actor(假设名字为B)的轴向。

AttachToActor函数附加选项有三种。分别是KeepRelative, KeepWorld, SnapToTarget。

假设ActorA原本已附加在ActorC上，ActorA原有的绝对位置为(100,100,100)，原有的相对位置为(50,50,50)，此时将ActorA附加在ActorB上时：

1. 如果采用KeepRelative策略，会基于ActorB的自身轴向，将ActorA的相对信息保留，即附加后，ActorA的相对位置仍然是(50,50,50)；
2. 如果采用KeepWorld策略，则会保持ActorA的绝对位置(100,100,100)不变，基于ActorB重新计算ActorA在ActorB的相对位置；
3. 如果采用SnapToTarget策略，会使ActorA使用ActorB的坐标轴，也就是会屏蔽掉ActorA的位置信息，哪怕ActorA的原有相对位置为(50,50,50)附加后相对位置也会变成(0,0,0)。
